# ADR - 2026-02-feishu

- Source: `code/pytbox/docs/specs/2026-02-feishu`
- Generated On: `2026-02-07`

## Merge Status

| File | Status | Date | Note |
| --- | --- | --- | --- |
| spec.md | Done | 2026-02-07 | Merged |
| 01-return-contract.md | Done | 2026-02-07 | Merged |
| 02-http-client-unification.md | Done | 2026-02-07 | Merged |
| 03-auth-token-cache.md | Done | 2026-02-07 | Merged |

## Merged Content

### spec.md

# Feishu Refactor Spec (Entry)

本次重构拆分为 3 个小 spec，按顺序执行，逐个闭环：

1) 01-return-contract.md
- 统一返回为 ReturnResponse（外部 IO 必须）
- 先做 wrapper/适配，保持兼容

2) 02-http-client-unification.md
- 统一 HTTP 栈（建议全部走 httpx）
- 统一 timeout / retry / 错误映射 / 日志

3) 03-auth-token-cache.md
- 统一 token 获取/刷新/缓存
- 移除 print/env 乱写，提升可控性与可测试性

全局约束：
- 必须遵守 AGENTS.md
- 小步改动，保持兼容（除非子 spec 明确列出 breaking change）
- 每个子 spec 都必须有 pytest 覆盖（mock 外部请求）

### 01-return-contract.md

# 01 - Return Contract

## Goal (MUST)
- 所有 Feishu 外部 IO（HTTP/API 调用）对外统一返回 `ReturnResponse`：
  `src/pytbox/schemas/response.py::ReturnResponse`
- 保持对外行为兼容：现有调用方不因重构而崩（允许先加 wrapper 过渡）

## Non-Goals (MUST NOT)
- 不在此阶段统一 HTTP 栈/重写 auth（留到后续子 spec）
- 不大规模改模块结构

## Current Issues
- client.request() 返回 FeishuResponse（dataclass），endpoints 部分返回 ReturnResponse/部分返回 FeishuResponse，存在混用。

## Design
- 新增/调整一层“适配器”，将 FeishuResponse -> ReturnResponse（或直接让 request 返回 ReturnResponse）
- 统一错误表达：
  - code：0 成功；非 0 失败（保留现有项目约定，如有）
  - message：简短描述
  - data：业务数据（dict/列表/原始结构）
  - error（可选）：包含 http_status/errcode/errmsg/req_id

## Acceptance Criteria (AC)
- AC1: Feishu 模块对外暴露的所有“会打飞书 API”的函数返回 ReturnResponse
- AC2: 不再出现同层混用（同一抽象层要么全 ReturnResponse，要么纯工具裸返回）
- AC3: 保留旧接口/导入路径（如必须改变，需提供兼容 wrapper）

## Tests
- mock HTTP 响应：success / 4xx / 5xx / timeout
- 验证：返回类型为 ReturnResponse；code/message/data 字段符合预期

### 02-http-client-unification.md

# 02 - HTTP Client Unification

## Goal (MUST)
- Feishu 模块只保留一个 HTTP 实现（建议统一为 httpx）
- 所有外部请求必须：
  - timeout（默认值明确）
  - retry <= 3（指数退避）
  - 不重试：参数/权限类 4xx（429 可作为例外重试）
- 统一 URL 构造：禁止在 endpoint 里写死完整域名（统一 base_url + path）

## Non-Goals (MUST NOT)
- 不在本阶段改变业务 API 语义
- 不引入重依赖（如 tenacity 非必需则先不用）

## Current Issues
- endpoints.py 存在 requests.request + MultipartEncoder
- client.py 使用 httpx
- 部分接口使用绝对 URL/部分相对 path

## Design
- 抽象一个 `HttpClient`（可在现有 client.py 内实现）：
  - request(method, path, *, params/json/data/files/headers)
  - 统一 headers 注入（含 token）
  - 统一异常捕获与错误映射为 ReturnResponse
- Multipart 上传：
  - 若必须：用 httpx 的 files/data 方案实现
  - 不再直接调用 requests

## Acceptance Criteria (AC)
- AC1: Feishu 代码中不再直接使用 requests 发送 HTTP
- AC2: 所有请求都有 timeout；超时会触发 retry（最多 3 次）
- AC3: endpoint 不再硬编码域名；统一走 base_url

## Tests
- mock httpx client：验证 timeout/retry 行为（至少验证重试次数与最终结果）
- 覆盖：429/5xx 可重试，4xx 不重试（除 429）

### 03-auth-token-cache.md

# 03 - Auth & Token Cache

## Goal (MUST)
- 统一 tenant_access_token 获取/刷新/缓存策略：
  - 单一来源、单一写入路径
  - 可测试、可控、可观测
- 禁止：
  - print
  - 随意写入 os.environ 作为持久缓存
- 日志不泄露 secret

## Non-Goals (MUST NOT)
- 不引入复杂分布式缓存（保持本地可用即可）
- 不改变配置注入方式（除非明确写出）

## Current Issues
- 使用 shelve /tmp/.feishu_token + 环境变量写入 + print 混用，行为不可预测。

## Design
- TokenProvider：
  - get_token() -> ReturnResponse(data={"token": "...", "expires_at": ...})
  - 缓存策略：内存优先，落盘可选（路径可配置）
  - 过期判断：提前 N 秒刷新（buffer）
- 并发/多进程：
  - 最小实现：简单文件锁或“失败可重试”的策略（按现状取舍）

## Acceptance Criteria (AC)
- AC1: 获取 token 只有一套逻辑入口（TokenProvider）
- AC2: 不再写 os.environ 作为缓存；不再出现 print
- AC3: token 过期可自动刷新；失败会返回 ReturnResponse 且日志可定位（不含 secret）

## Tests
- mock token API：首次获取、命中缓存、过期刷新、刷新失败
- 验证：不会把 token 写到日志/异常里（至少验证日志内容不包含 token 字符串）

